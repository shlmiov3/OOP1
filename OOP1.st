Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'Get&Set' stamp: 'HW1 8/2/2018 22:32'!coef	^coef! !!Monom methodsFor: 'Get&Set' stamp: 'HW1 8/2/2018 22:37'!coef: anInteger	(anInteger isKindOf: Integer) 		ifTrue: [ coef := anInteger.]		ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'Get&Set' stamp: 'HW1 8/2/2018 21:54'!exp	^exp.! !!Monom methodsFor: 'Get&Set' stamp: 'HW1 8/2/2018 22:27'!exp: anInteger	( (anInteger isKindOf: Integer) and: [anInteger >= 0] ) 		ifTrue: [ exp := anInteger.]		ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'Methods' stamp: 'HW1 8/5/2018 20:05'!* aMonom	self exp: (self exp) + (aMonom exp).	self coef: (self coef) * (aMonom coef).! !!Monom methodsFor: 'Methods' stamp: 'HW1 8/2/2018 23:06'!+ aMonom	(self exp = aMonom exp) ifTrue: [self coef: self coef + aMonom coef].! !!Monom methodsFor: 'Methods' stamp: 'HW1 8/4/2018 20:38'!= aMonom	^(self exp = aMonom exp).! !!Monom methodsFor: 'Methods' stamp: 'HW1 8/6/2018 11:58'!derivative	|newMonom|	newMonom := Monom new.	newMonom coef: (self exp) * (self coef).	(exp -1 < 0) ifFalse: [newMonom exp: self exp -1.]	ifTrue: [newMonom exp: 0].	^newMonom! !!Monom methodsFor: 'Methods' stamp: 'HW1 8/2/2018 23:59'!eval: anInteger	(anInteger isKindOf: Integer) ifFalse: [self error: 'invalid input'].	^(coef * (anInteger raisedTo: exp))! !!Monom methodsFor: 'printing' stamp: 'HW1 8/2/2018 22:46'!printOn: aStream	|aMonom|	aMonom := (self coef asString , 'X' , '^' , self exp asString).	aStream nextPutAll: aMonom! !!Monom methodsFor: 'initialize-release' stamp: 'HW1 8/2/2018 22:18'!initialize	exp := 0.	coef := 0.! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'initialize-release' stamp: 'HW1 8/5/2018 22:26'!initialize	block := [:val :filterSet | 0].! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:39'!add: aPolyStream	(aPolyStream isKindOf: PolyStream) ifFalse: [self error: 'invalid input'].	block := [:val :filterSet | ((aPolyStream block) value: val value: filterSet) + (self block value: val value: filterSet)].! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:41'!addCoef: coef withExp: exp	(((coef isKindOf: Integer) and: [exp isKindOf: Integer]) and: [exp > 0]) ifFalse: (self error: 'invalid input').	block := [:val :filterSet | (block value:val value:filterSet) + (filterSet includes: exp) ifTrue: [0] ifFalse: [coef*(val raisedTo: exp)]]! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:35'!block	^block! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 23:11'!eval: anInteger	(anInteger isKindOf: Integer) ifFalse: [self error: 'invalid input'].	^(block value: anInteger value: (Set new))! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:45'!filter: aSet	|newSet|	newSet := aSet deepCopy.	block := [:val :filterSet | block value:val value:(newSet union: filterSet)].! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 23:09'!intersectionWith: aPolyStream withinRange: anInteger	|i|	((anInteger isKindOf: Integer) and: [aPolyStream isKindOf: PolyStream]) ifFalse: [self error: 'invalid input'].	i := 0.	^[ 		(i abs > anInteger) ifTrue: [self error: 'error raised'].		(block value:i value:(Set new) = (aPolyStream block) value:i value:(Set new)) 				ifTrue: [ i ]				ifFalse:[					(i>=0) ifTrue: [						(i=0) ifTrue: [i := i+1]						ifFalse: [ i := i negate].						'wait for it...'					]					ifFalse: [						i := i negate + 1.						'wait for it...'.					]				]			]! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:44'!multiplyBy: anInteger	(anInteger isKindOf: Integer) ifFalse: [self error: 'invalid input'].	block := [:val :filterSet | (block value:val value: filterSet)*anInteger].! !!PolyStream methodsFor: 'methods' stamp: 'HW1 8/5/2018 22:42'!substitute: anInteger	((anInteger isKindOf: Integer) and: [anInteger > 0]) ifFalse: [self error: 'invalid input'].	block := [:val :filterSet | block value:(val*anInteger) value:filterSet].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'initialize-release' stamp: 'HW1 8/2/2018 23:18'!initialize	monoms := Set new.! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/5/2018 19:36'!Add: aPolynom	|newPolynom|	newPolynom := self deepCopy.	aPolynom do: [:x | newPolynom addMonom: x].	monoms reject: [:x | x coef = 0].	^newPolynom.	! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/6/2018 12:38'!addMonom: aMonom	|copyMonom|	(aMonom isKindOf: Monom) ifFalse: [self error: 'invalid input'].	(aMonom coef = 0) 	ifFalse:	[( (self contains: aMonom))		ifTrue: [		monoms do: [:x | 			(x exp = aMonom exp) 			ifTrue: [x+aMonom.]]]			ifFalse: [				copyMonom := aMonom deepCopy.				monoms add: copyMonom.			]	].	monoms := monoms select: [:x | (x coef = 0) not]. 			! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/6/2018 12:01'!asDictionary	|aDictionary|	aDictionary := Dictionary new.	self monoms do: [:x | aDictionary at: (x exp) put: (x coef)].	^aDictionary.! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/6/2018 12:29'!contains: aMonom	monoms do: [:x | (x=aMonom) ifTrue: [Transcript showln: 'FOUND'.^true]].	^false	! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/2/2018 23:54'!derivative	| newPolynom |	newPolynom := Polynom new.	monoms do: [:x | 		newPolynom addMonom: (x derivative)].	(newPolynom monoms) reject: [:x | x coef = 0].	^newPolynom	! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/3/2018 00:02'!eval: anInteger	| sum |	(anInteger isKindOf: Integer) ifFalse: [self error: 'invalid input'].	sum := 0.	monoms do: [:x | sum:= sum + (x eval: anInteger)].	^sum	! !!Polynom methodsFor: 'Methods' stamp: 'HW1 8/5/2018 20:17'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom) ifFalse: [self error: 'invalid input'].	monoms collect: [:x | x*aMonom].	monoms reject: [:x | x coef = 0].! !!Polynom methodsFor: 'Get&Set' stamp: 'HW1 8/2/2018 23:54'!monoms	^monoms! !!Polynom methodsFor: 'printing' stamp: 'HW1 8/5/2018 19:54'!printOn: aStream	|aPolynom|	aPolynom := String new.	self monoms do: [:x | aPolynom := aPolynom ,  x , ' '].	aStream nextPutAll: aPolynom! !TestCase subclass: #TestPartA	instanceVariableNames: 'mn monomD pn derivativePn'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!TestPartA methodsFor: 'Tests' stamp: 'HW1 8/4/2018 21:07'!test	Transcript showln: 'Monom Test'.	mn := Monom new.	"Check Monom exp and coef failure error"	 [mn exp: -2] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [mn coef: 0.5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	mn exp: 2.	mn coef: 3.	"Check Monom exp and coef method"	self assert: ((mn exp = 2) and: [mn coef = 3]).	"Check Monom Derivative method"	monomD := mn derivative.	self assert: ((monomD exp = 1) and: [monomD coef =6]).	"Test +,* = methods"	mn + monomD.	self assert: ((mn exp = 2) and: [mn coef = 3]).	mn := mn derivative.	self assert: (mn = monomD).	mn + monomD.	self assert: ((mn exp = 1) and: [mn coef = 12]).	mn * monomD.	self assert: ((mn exp = 2) and: [mn coef = 72]).		"Check eval method"	self assert: ((monomD eval: 2) = 12).		Transcript showln: 'Monom Success'.	! !!TestPartA methodsFor: 'Tests' stamp: 'HW1 8/6/2018 11:53'!testPartA_COEF	|m|	m := Monom new.	m coef: -3.	self assert: ((m coef)= -3).	m coef: -0.	self assert: ((m coef)= 0).	m coef: 13.	self assert: ((m coef)= 13).	m coef: 0.	self assert: ((m coef)= 0).	 [m coef: 0.5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m coef: -0.5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m coef: $F] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m coef: 5.0] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].! !!TestPartA methodsFor: 'Tests' stamp: 'test 8/6/2018 01:07'!testPartA_DERIVATIVE	|m ret_m|	m := Monom new.	ret_m := m derivative.	self assert: (((ret_m coef) = 0) and:[(ret_m exp) = 0]).		m exp: 0.	m coef: 1.	ret_m := m derivative.	self assert: (((ret_m coef) = 0) and:[(ret_m exp) = 0]).		m exp: 1.	m coef: 0.	ret_m := m derivative.	self assert: (((ret_m coef) = 0) and:[(ret_m exp) = 0]).		m exp: 0.	m coef: -1.	ret_m := m derivative.	self assert: (((ret_m coef) = 0) and:[(ret_m exp) = 0]).		m exp: 2.	m coef: -2.	ret_m := m derivative.	self assert: (((ret_m coef) = -4) and:[(ret_m exp) = 1]).	m exp: 2.	m coef: 2.	ret_m := m derivative.	self assert: (((ret_m coef) = 4) and:[(ret_m exp) = 1]).			m exp: 15.	m coef: 2.	ret_m := m derivative.	self assert: (((ret_m coef) = 30) and:[(ret_m exp) = 14]).	m exp: 7.	m coef: 8.	self assert: (((ret_m coef) = 30) and:[(ret_m exp) = 14]).! !!TestPartA methodsFor: 'Tests' stamp: 'HW1 8/6/2018 11:53'!testPartA_EXP	|m|	m := Monom new.	m exp: 13.	self assert: ((m exp)= 13).	 [m exp: 0.5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m exp: -0.5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m exp: -5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m exp: $5] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	 [m exp: 5.0] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].	m exp: 0.	self assert: ((m exp)= 0).	! !!TestPartA methodsFor: 'Tests' stamp: '? 8/6/2018 12:52'!testPartA_POLY_ADDMONOM	|p p2 p_dic m currect_res|		m := Monom new.	m exp: 2. m coef: -2.		currect_res := Dictionary new.	currect_res at: 1 put: 2.	currect_res at: 2 put: -2.		p:= Polynom new.	p addMonom: m.		m exp: 1. m coef: 2.	p addMonom: m.		p_dic := p asDictionary.	self assert: (p_dic = currect_res).	self assert:(self testPartA_POLY_STATE: p).	"================================================================"	m := Monom new.	m exp: 1. m coef: 2.		p:= Polynom new.	p addMonom: m.		m exp: 1. m coef: -2.	p addMonom: m.		p_dic := p asDictionary.	self assert: (p_dic = Dictionary new)."================================================================"	m := Monom new.	p:= Polynom new.		m exp: 1. m coef: 2.	p addMonom: m.		m exp: 2. m coef: 2.	p addMonom: m.		m exp: 2. m coef: -2.	p addMonom: m.		currect_res := Dictionary new.	currect_res at: 1 put: 2.		p_dic := p asDictionary.	self assert: (p_dic = currect_res)."================================================================"	m := Monom new.	p:= Polynom new.		m exp: 1. m coef: 2.	p addMonom: m.		m exp: 0. m coef: 0.	p addMonom: m.		currect_res := Dictionary new.	currect_res at: 1 put: 2.		p_dic := p asDictionary.	self assert: (p_dic = currect_res).	"================================================================"	m := Monom new.	p:= Polynom new.		p addMonom: m.		p_dic := p asDictionary.	self assert: (p_dic = Dictionary new).	"================================================================"	m := Monom new.	p:= Polynom new.	p2:= Polynom new.		m exp: 1. m coef: 2.	p addMonom: m.	p2 addMonom: m.		m exp: 2. m coef: 2.	p addMonom: m.	p2 addMonom: m.	 [p addMonom: p2] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])].		"================================================================"	m := Monom new.	p:= Polynom new.		m exp: 1. m coef: 2.	p addMonom: m.		m exp: 2. m coef: 2.	p addMonom: m.	[p addMonom: (0.2)] on: Error do: [:e | (e asString = 'Error: invalid input' ifFalse: [Transcript showln: e asString])]."================================================================"	m := Monom new.	p:= Polynom new.		m exp: 1. m coef: 2.	p addMonom: m.		m exp: 2. m coef: -2.	p addMonom: m.		m exp: 5. m coef: 4.		currect_res := Dictionary new.	currect_res at: 1 put: 2.	currect_res at: 2 put: -2.		p_dic := p asDictionary.	self assert: (p_dic = currect_res)."================================================================"	m := Monom new.	p:= Polynom new.		m exp: 4. m coef: 2.	p addMonom: m.		m exp: 4. m coef: -3.	p addMonom: m.			currect_res := Dictionary new.	currect_res at: 4 put: -1.		p_dic := p asDictionary.	self assert: (p_dic = currect_res).! !!TestPartA methodsFor: 'Tests' stamp: '? 8/6/2018 12:49'!testPartA_POLY_STATE: aPolynom	| p_dic |	p_dic := aPolynom asDictionary.	((p_dic occurrencesOf: 0) = 0) ifFalse: [^false] ifTrue: [^true].! !!TestPartA methodsFor: 'Tests' stamp: 'test 8/6/2018 01:11'!testPartA_POLY_Sainity	|p p_dic|	p := Polynom new.	p_dic := p asDictionary.	self assert: (p_dic = Dictionary new).! !!TestPartA methodsFor: 'Tests' stamp: 'HW1 8/6/2018 12:40'!testPartA_Sainity	|m|	m := Monom new.	self assert: ((m exp = 0) and: [m coef = 0]) .	m exp: 5.	m coef: 6.	self assert: ((m exp = 5) and: [m coef = 6]) .! !!TestPartA methodsFor: 'Tests' stamp: 'HW1 8/6/2018 12:30'!testPolynom	Transcript showln: 'Polynom Test'.	mn := Monom new.	pn := Polynom new.	mn exp: 2.	mn coef: 3.	"Check addMonom, eval and derivative"		monomD := mn derivative.	pn addMonom: mn.	pn addMonom: monomD.	mn exp: 5.	Transcript showln: 'pn ', pn.	self assert: ((pn eval: 1) = 9).	derivativePn := pn derivative.	self assert: ((derivativePn eval: 1) = 12).	"Check multiply"	pn multiplyByMonom: monomD.	self assert: ((pn eval: 1) = 54).	Transcript showln: 'Polynom Success'.! !